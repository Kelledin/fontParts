"""
Things that should be considered for removal:
- anything that does anything too magical.
- anything that was originally implemented for
  environment specific reasons.
- anything that was designed as a speed optimization.

Things that haven't been defined, but should.
- the selected attribute for glyph and below.
- a common error instead of relying on the environment
  errors. those often differ from environment
  to environment and that's a portability problem.
- what errors should be raised by each method
- an interpolation method for all realistic objects.
  this way font.interpolate can just iterate through
  those.
- classes for subobjects need to be declared in the
  parent objects.
- the class to use for a copy operation needs to
  be defined for each object that has a copy method.
- should the transformation, round, etc. methods modify
  guidelines? if so, those methods should probably
  gain new arguments that allow for selectively
  applying the operation. for example:

    glyph.scale(guidelines=False)
- color format. use something similar to defcon's color object.

Things that we should consider adding:
- a naming convention for environment specific
  things. for example, it would be bad if two
  environments defined "makeMyFont" but they took
  different arguments and did different things.
- a parent tree system like in defcon. this would
  replace the fragile getParent.

Big questions:
- should robofab handle validation of incoming values?
  this would make it easier on subclasses because they
  wouldn't have to do their own validation. We could do
  this by defining internal getters setters that the
  core methods would call. For example:

  class BasePoint(BaseObject):

    type = dynamicProperty("base_type")

    def _get_base_type(self):
      return self._get_type()

    def _set_base_type(self, value):
      if value not in ("move", "line", "curve", "qurve", "offcurve"):
        raise FontPartsError("Unknown point type: %r" % value)
      self._set_type(value)


  class AdapterPoint(BasePoint):

    def _get_type(self):
      self.raiseNotImplementedError()

    def _set_type(self, value):
      self.raiseNotImplementedError()


  class RPoint(AdapterPoint):

    def _get_type(self):
      return self.naked().type

    def _set_type(self, value):
      self.naked().type = value


- we need to find a way to make it very clear to subclassers
  what they should and should not implement. with the previous
  robofab, we ran into situations where the base code was copied
  and pasted, including unnecessary code duplication. perhaps
  the way to do this is to have an intermediary set of objects
  that can be duplicated completely without problem becuase the
  file contains only method stubs. The object relationship
  could then be like this:

  base > adapter > environment

- A better way may be to have a subclassing termplate.
  it could even be auto generated by going through the
  base objects and looking for specific identifiers
  in documentation strings. Something like this:

  font = BaseFont()
  print font.__class__.__name__.replace("Base", "My")
  for attr in sorted(dir(font)):
      try:
          m = getattr(font, attr)
          if "subclasses must override this method" in m.__doc__.lower():
              print attr
      except AttributeError:
          pass

  There would need to be something smarter that
  gets the attributes in the proper order with the
  args and kwargs.
"""
