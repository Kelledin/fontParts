"""
The goal is to define a very clean scripting API
that preserves the main functionality of RoboFab.
Say something about the importance of script
portability. Designers have workflows and specific
binary requirements, etc.

Things that should be considered for removal:
- anything that does anything too magical.
- anything that was originally implemented for
  environment specific reasons.
- anything that was designed as a speed optimization.

Things that haven't been defined, but should.
- the selected attribute for glyph and below.
- a common error instead of relying on the environment
  errors. those often differ from environment
  to environment and that's a portability problem.
- what errors should be raised by each method
- an interpolation method for all realistic objects.
  this way font.interpolate can just iterate through
  those.
- classes for subobjects need to be declared in the
  parent objects.
- the class to use for a copy operation needs to
  be defined for each object that has a copy method.
- should the transformation, round, etc. methods modify
  guidelines? if so, those methods should probably
  gain new arguments that allow for selectively
  applying the operation. for example:

    glyph.scale(guidelines=False)

Things that we should consider adding:
- a naming convention for environment specific
  things. for example, it would be bad if two
  environments defined "makeMyFont" but they took
  different arguments and did different things.
- a parent tree system like in defcon. this would
  replace the fragile getParent.

Big questions:
- should robofab handle validation of incoming values?
  this would make it easier on subclasses because they
  wouldn't have to do their own validation. We could do
  this by defining internal getters setters that the
  core methods would call. For example:

  class BasePoint(BaseObject):

    type = dynamicProperty("base_type")

    def _get_base_type(self):
      return self._get_type()

    def _set_base_type(self, value):
      if value not in ("move", "line", "curve", "qurve", "offcurve"):
        raise FontPartsError("Unknown point type: %r" % value)
      self._set_type(value)


  class AdapterPoint(BasePoint):

    def _get_type(self):
      self.raiseNotImplementedError()

    def _set_type(self, value):
      self.raiseNotImplementedError()


  class RPoint(AdapterPoint):

    def _get_type(self):
      return self.naked().type

    def _set_type(self, value):
      self.naked().type = value


- we need to find a way to make it very clear to subclassers
  what they should and should not implement. with the previous
  robofab, we ran into situations where the base code was copied
  and pasted, including unnecessary code duplication. perhaps
  the way to do this is to have an intermediary set of objects
  that can be duplicated completely without problem becuase the
  file contains only method stubs. The object relationship
  could then be like this:

  base > adapter > environment

- A better way may be to have a subclassing termplate.
  it could even be auto generated by going through the
  base objects and looking for specific identifiers
  in documentation strings. Something like this:

  font = BaseFont()
  print font.__class__.__name__.replace("Base", "My")
  for attr in sorted(dir(font)):
      try:
          m = getattr(font, attr)
          if "subclasses must override this method" in m.__doc__.lower():
              print attr
      except AttributeError:
          pass

  There would need to be something smarter that
  gets the attributes in the proper order with the
  args and kwargs.


-----------
UFO 3 Stuff
-----------

font
----
# layers = font.layers
# list = font.glyphOrder (or should this go to info?)
# guideline = font.guidelines[index]
# guideline = font.appendGuideline
# font.removeGuideline(index)
# font.clearGuidelines

layers
------
list = layers.layerOrder
layer = layers.defaultLayer
layers.defaultLayer = layer
del layer[name]
layer = layers[name]
layer = layers.newLayer(name)
for name in layers:
int = len(layers)
name in layers (also do has_key for consistency)
list = layers.keys()

Hm. Presenting this sub-object seems a bit too UFO centric.
Perhaps everything should be done through the font.

layer list = font.layers (don't allow list operations beyond len, __getitem__ and __iter__)
name list = font.layerOrder
font.layerOrder = name list
name = font.defaultLayer
font.defaultLayer = name
layer = font.newLayer(name, color)
layer = font.getLayer(name)
font.removeLayer(name)

There also needs to be some convenience in the
glyph API for getting to a different layer.
In a script, jumping to the font and back is
going to be counter intuitive.

otherGlyph = glyph.layer(name)

# layer
# -----
# glyph = layer.newGlyph(same as font)
# glyph = layer.insertGlyph(same as font)
# for name in layers:
# glyph = layer[name]
# del layer[name]
# int = len(layer)
# name in layer (also do has_key for consistency)
# list layer.keys()
# layer.name = something
# something = layer.name
# color = layer.color
# layer.color = color
# layer.componentMapping (same as font)
# layer.characterMapping (same as font)
# layer.lib

# glyph
# -----
# int = glyph.height
# glyph.height = int
# color = glyph.markColor
# glyph.markColor = color
# guideline = glyph.guidelines[index]
# guideline = glyph.appendGuideline
# glyph.removeGuideline(index)
# glyph.clearGuidelines
# glyph.image = image
# image = glyph.image

# contour
# -------
# str = contour.identifier
# contour.identifier = str

# point
# -----
# str = point.identifier
# point.identifier = str

# component
# ---------
# str = component.identifier
# component.identifier = str

# anchor
# ------
# color = anchor.color
# anchor.color = color
# str = anchor.identifier
# anchor.identifier = str

# image
# -----
# matrix = image.transformation
# image.transformation = matrix
# (add scale and offset like in component)
# str = image.fileName
# image.fileName = str
# color = image.color
# image.color = color
# data = image.data
# image.data = data

Don't present an interface to the core image set.
That is very UFO specific. The only tricky thing
that I can think of right now would be if two glyphs
have images with the same name but different data.
That would need to be managed in the defcon wrapper.

# guideline
# ---------
# x
# y
# angle
# name
# color
# identifier

data
----
Don't provide direct access to this. It's very UFO specific.

color
-----
(r, g, b, a)
Maybe use something very similar to defcon's color object.
"""
